# 2주차 회고록

## 2주 차: 안전한 설계를 위한 타입 시스템 (Null Safety & Class)

- **핵심 주제**: 자바의 NullPointerException을 코틀린은 어떻게 방어하는가?
- **학습 내용**: [강의] Part 0. Kotlin 기초 (클래스, Null, 타입체크와 캐스팅)
  - **Null Safety**: Nullable과 Non-nullable 타입은 바이트코드 수준에서 어떻게 구분되는가? (Java와의 상호운용성 관점).
  - **클래스와 설계**: 코틀린의 class는 기본적으로 final이다. 상속을 닫아둔 설계 철학은 무엇이며, 이것이 유지보수에 미치는 영향은?
  - **데이터 클래스**: data class가 자동으로 생성해 주는 메서드(equals, hashCode 등)는 객체 비교에서 어떤 이점을 주는가?

---

### 1. 널 안전성 (Null Safety)

코틀린의 설계 철학 중 가장 핵심적인 부분은 '런타임에 발생할 NPE를 컴파일 시점으로 끌어오는 것'임을 이해했다.

- **타입 시스템의 분리**: 코틀린은 `String`(Non-nullable)과 `String?`(Nullable)을 완전히 다른 타입으로 취급한다. 이를 통해 널이 될 수 있는 변수에 직접 접근하는 코드를 컴파일 단계에서 원천 차단함을 확인했다.
- **바이트코드와 애노테이션**: JVM 수준에서 모든 객체는 널이 될 수 있지만, 코틀린 컴파일러는 `@NotNull`과 `@Nullable` 애노테이션을 바이트코드에 삽입하여 이를 구분하고 강제한다는 점을 알게 됐다.
- **안전한 연산자**: 엘비스 연산자(`?:`)와 세이프 콜(`?.`)을 사용하면 자바의 번거로운 `if (x == null)` 코드를 획기적으로 줄이면서도 가독성을 높일 수 있음을 체감했다.

### 2. 플랫폼 타입 (Platform Type, `T!`)

자바에서 정의된 타입을 코틀린에서 가져올 때, 코틀린은 해당 값이 null인지 아닌지 알 수 없는 위험성을 알게 되었다.

- **정의**: 자바에서 정의된 타입 중 널 가능성 정보(애노테이션)가 없는 타입을 코틀린은 **플랫폼 타입**으로 간주한다.
- **표기법 (`T!`)**: `T`는 임의의 타입을 뜻하는 플레이스홀더이며, `!`는 널 여부를 알 수 없으니 주의하라는 컴파일러의 경고임을 이해했다.
- **개발자의 책임**: 플랫폼 타입은 널 가능 여부를 개발자가 직접 판단해야 하며, 잘못 판단하여 Non-null로 선언하고 사용하다가 널이 들어올 경우 런타임 에러가 발생한다는 위험성을 인지했다.

### 3. 클래스 설계와 상속

코틀린이 왜 상속에 보수적인 언어인지 그 설계 철학을 파악했다.

- **Default final**: 코틀린의 클래스는 기본적으로 `final`이다. 상속을 허용하려면 `open` 키워드를 명시해야 한다.
- **취약한 기반 클래스 문제(Fragile Base Class)**: 무분별한 상속이 부모 클래스의 변경을 어렵게 만들고 유지보수를 해친다는 점을 방지하기 위한 설계임을 이해했다.
- **의도적인 설계**: "상속을 위해 설계하고 문서화하지 않았다면 상속을 금지하라"는 원칙을 언어 차원에서 강제함으로써, 더 견고한 객체지향 구조를 고민하게 만든다는 점을 알게 됐다.

### 4. 데이터 클래스 (Data Class)

데이터 클래스는 단순히 코드 양을 줄여주는 편의 기능을 넘어, **"데이터는 값으로 존재하고 비교되어야 한다"**는 철학을 언어 차원에서 강제하고 있음을 알게 됐다.

- **보일러플레이트 제거**: 주 생성자의 프로퍼티를 기반으로 `equals()`, `hashCode()`, `toString()` 등을 클래스 앞에 data를 붙이면 컴파일러가 자동으로 생성해 주어 자바 대비 코드량이 압도적으로 줄어듦을 확인했다.
  - equals(): 객체의 참조(주소)가 아닌 속성 값들이 같은지 비교 -> 객체 간의 동등성 비교가 매우 직관적
  - hashCode(): 객체의 속성 값들을 기반으로 해시 코드를 생성 (HashMap 등에서 중요)
  - toString(): User(name=JW, age=20)와 같이 예쁜 문자열로 출력
  - copy(): 객체의 복사본을 만들되, 일부 속성만 변경할 수 있게 해줌 -> 함수형 프로그래밍의 불변성 원칙을 지키기 수월
  - componentN(): 구조 분해 할당(Destructuring Declaration)을 가능하게 함
- **클래스 설계 제약의 이유**: 데이터 클래스에 부여된 제약 사항들이 데이터의 일관성을 유지하기 위한 필수적인 선택임을 파악했다.
  - final의 강제: 데이터 클래스는 기본적으로 final이며 open일 수 없다. 이는 상속 구조에서 데이터 동등성(Equality) 비교가 복잡해지거나 논리적 오류가 생기는 것을 방지하기 위함임을 이해했다.
  - abstract 금지: 데이터 클래스는 실제 인스턴스를 생성하여 데이터를 보유하는 것이 목적이므로, 추상 클래스일 수 없음을 알게 됐다.
  - inner 클래스 불가: 바깥 클래스에 대한 숨겨진 참조를 가질 경우, 데이터의 순수성이 훼손되고 비교 로직이 복잡해지기 때문에 금지됨을 이해했다.
  - 생성자 제약: 주 생성자에 최소 한 개 이상의 val 또는 var 파라미터가 필요한 이유는, 컴파일러가 이 프로퍼티들을 기준으로 자동 메서드를 만들기 때문임을 알게 됐다.

---

## 2주차 요약

2주 차 학습을 통해 코틀린은 **실수를 줄이고 유지보수가 쉬운 구조를 만들도록 강제하는 도구**라는 사실을 깨달았다. 특히 플랫폼 타입의 위험성을 이해하며 자바 라이브러리를 사용할 때 더 세심한 주의가 필요함을 배웠다.

---
