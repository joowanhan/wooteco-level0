# 1주차 회고록

## 1주 차: 언어의 뿌리와 실행 환경 (JVM & Variable)
- **핵심 주제**: 코틀린은 어떻게 실행되는가? (JVM, 메모리, 변수)
- **학습 내용**: [강의] Part 0. Kotlin 기초 (오리엔테이션 ~ 변수, 조건식)
    - **컴파일 과정**: .kt 파일이 .class로 변환되는 과정과 JVM의 역할 (Python 인터프리터 방식과의 차이점).
    - **변수와 메모리**: val(읽기 전용)과 var의 차이가 메모리(Stack/Heap) 관점에서 어떻게 다른가? const val은 컴파일 시점에 어떻게 처리되는가?
    - **타입 시스템**: 코틀린의 타입 추론(Type Inference)은 컴파일 타임에 어떻게 확정되는가?

---

우아한테크코스 Level 0 과정을 시작하며, 첫 주는 특정 기술의 사용법보다는 **"코틀린이라는 언어가 왜 이렇게 설계되었는가?"**에 집중하며 학습했다. Java와 비교하며 JVM 위에서 돌아가는 이 언어의 뿌리와, 변수 및 타입 시스템에 숨겨진 철학을 파헤쳐 보았다.

## 1. 코틀린은 어떻게 실행되는가? (JVM & Compile)

가장 먼저 `.kt` 파일이 실행되는 과정을 살펴보았다. Python 같은 인터프리터 언어와 달리, 코틀린은 컴파일 언어다.

* **컴파일 과정**: `kotlinc` 컴파일러가 소스 코드를 분석하여 **바이트코드(.class)**를 생성한다.
* **JVM의 역할**: 생성된 바이트코드는 자바의 것과 동일한 규격을 따르며, JVM 위에서 실행된다. 즉, 코틀린은 자바 생태계를 100% 활용하면서도 문법적인 개선을 이룬 언어다. 이 과정은 자바 컴파일러(javac)가 하는 일과 동일하며, 생성된 바이트코드는 JVM 입장에서 자바 코드로 생성된 것인지 코틀린으로 생성된 것인지 구분할 수 없다.
* **Why?**: 컴파일 타임에 강력한 타입 체크를 수행하여 런타임 오류를 줄이고 성능을 확보하기 위함이다.
* **런타임 라이브러리**: 하지만 코틀린은 자바 표준 라이브러리를 그대로 쓰면서도 last(), sum() 같은 편리한 기능을 제공한다. 이는 코틀린이 **런타임 라이브러리(Kotlin Runtime Library)**를 통해 자바 클래스에 기능을 덧붙이기(Extension) 때문이다. 덕분에 런타임 오버헤드 없이 자바 컬렉션을 그대로 사용할 수 있다.

---

### 1-1. `.class` 파일과 `class` 키워드의 관계

학습 도중 문득 의문이 들었다. *"컴파일 결과가 `.class` 파일이라는데, 내가 코드에 `class`를 안 써도 `.class`가 생기나? 객체 지향의 클래스와 파일 확장자는 같은 건가?"*

이 질문을 파고들며 **JVM의 동작 원리**를 더 명확히 이해하게 되었다.

#### 1) `kotlinc`: 번역가 (Compiler)

우리가 작성한 `.kt` 코드는 사람을 위한 것이다. 이를 기계(JVM)가 이해하려면 번역이 필요하다.

* `kotlinc`는 코틀린 코드를 **바이트코드(Bytecode)**로 변환하는 컴파일러다.
* 이 바이트코드는 OS가 아니라 **JVM** 위에서만 실행되는 전용 명령어 집합이다.

#### 2) `.class` 파일: 포장지 (File Format)

JVM은 모든 코드를 **'클래스 파일(.class)'**이라는 단위로 읽어들인다.

* **객체 지향의 `class`**: 개발자가 정의한 객체의 설계도 (논리적 개념).
* **파일 확장자 `.class`**: JVM이 코드를 관리하고 저장하는 **바이트코드 파일 포맷** (물리적 형태).

#### 3) 클래스 없이 함수만 작성했을 때 (`Example2.kt`)

자바와 달리 코틀린은 파일 최상단(Top-level)에 함수를 작성할 수 있다. 그렇다면 클래스가 없는 걸까?
아니다. 컴파일러(`kotlinc`)가 **자동으로 클래스를 생성**해 준다.

* **소스 코드 (`Example2.kt`)**:
```kotlin
fun main() { ... }
fun times(a: Int, b: Int) = a * b

```


* **컴파일 결과 (`Example2Kt.class`)**:
* 컴파일러는 파일명 뒤에 `Kt`를 붙인 클래스(`Example2Kt`)를 자동으로 생성한다.
* `main`과 `times` 함수는 이 클래스 내부의 **static 메서드**처럼 변환되어 포함된다.



**결론**: 코틀린이 "자바와 100% 호환된다"는 말은, 결국 코틀린도 자바처럼 **모든 것을 `.class` 파일이라는 포장지에 담아 JVM에 전달하기 때문**이다. JVM 입장에서는 누가 짰는지 중요하지 않다. 바이트코드만 있으면 된다!

## 2. 변수와 불변성 (Variable & Memory)

`Example3.kt`를 실습하며 `val`과 `var`의 차이를 메모리 관점에서 정리했다.

### val (Read-only) vs var (Mutable)

* **val**: Java의 `final`과 유사하다. 한 번 초기화하면 재할당할 수 없다.
* **var**: 값이 변경될 수 있는 변수다.

### 메모리 관점의 '불변'이란?

학습 중 가장 흥미로웠던 점은 `val`이 **"객체 내부의 불변"을 보장하지 않는다**는 것이다.

```kotlin
val list = mutableListOf(1, 2, 3)
list.add(4) // 가능!
// list = mutableListOf(5) // 불가능 (재할당 금지)

```

* `val`은 **Stack** 영역에 있는 참조 변수(주소값)가 변경되지 않음을 보장한다.
* 하지만 그 참조가 가리키는 **Heap** 영역의 객체 데이터는 변경될 수 있다.
* 진정한 불변성을 원한다면 `List` 대신 `ImmutableList` 등을 사용해야 한다.

## 3. 식(Expression)과 문(Statement)

Java 개발자가 코틀린을 처음 접했을 때 가장 크게 느끼는 차이점 중 하나는 **"모든 것이 식(Expression)이 될 수 있다"**는 점이다. (`Example2.kt`, `Example5.kt` 참고)

### Java와의 차이

* **Java**: `if`, `switch`는 문(Statement)이다. 값을 반환하지 않고 흐름만 제어한다.
* **Kotlin**: `if`, `when`은 식(Expression)이다. 값을 반환하여 변수에 할당할 수 있다.

```kotlin
// Example5.kt 실습 코드
fun max3(a: Int, b: Int) {
    // 3항 연산자 없이 if문 자체를 값으로 사용
    val result = if (a > b) a else b 
    println(result)
}

```

이 덕분에 코틀린에는 3항 연산자(`condition ? true : false`)가 존재하지 않는다. `if-else`가 그 역할을 완벽히 대체하기 때문이다.

## 4. 클래스 설계와 상속의 제약 (`final` by default)

`Example4.kt`를 작성하며 코틀린의 클래스 설계 철학을 엿볼 수 있었다.

### 보일러플레이트의 제거

* Java: 필드 `private`, `Getter`, `Setter`, `생성자` 등 장황한 코드가 필요하다.
* Kotlin: `class User(val name: String)` 한 줄이면 프로퍼티 선언과 생성자, 접근자가 모두 해결된다.

### 상속 금지가 기본 (`open` 키워드)

코틀린의 클래스와 메서드는 기본적으로 `final`이다. 상속을 하려면 명시적으로 `open`을 붙여야 한다.

```kotlin
// 상속을 허용하려면 open이 필수
open class User(open val name: String, open var age: Int = 100)

class Kid(override val name: String, override var age: Int) : User(name, age)

```

이는 *"상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라"*는 **Effective Java**의 지침을 언어 레벨에서 강제한 것이다. 무분별한 상속으로 인한 '깨지기 쉬운 기반 클래스' 문제를 예방하려는 코틀린의 안전 지향적 철학이 돋보인다.

## 1주 차 요약

이번 주는 코틀린의 문법을 익히는 것을 넘어, **"코틀린이 자바의 어떤 불편함을 해결하려고 했는가?"**를 이해하는 시간이었다.

* 안전성: 컴파일 타임 검증 강화 (`val`, 타입 추론)
* 간결성: 표현식 중심의 코딩 (`expression`), 보일러플레이트 제거
* 명확성: 상속의 명시적 허용 (`open`)

---
