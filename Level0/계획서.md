# 레벨0 학습 계획서

## 1. 최종 목표
다음 3가지 목표를 통해 코틀린이라는 언어가 자바의 어떤 한계를 극복하기 위해 등장했는지 설계 철학을 이해하기

1. **언어의 본질 이해**: 코틀린 코드가 컴파일되어 JVM 상에서 어떻게 동작하는지(Bytecode 레벨) 설명할 수 있다.
2. **비교 분석 능력**: Java(또는 Python 등 다른 언어)와의 메모리 관리, 타입 시스템 차이를 명확히 설명하고, 상황에 맞는 문법을 선택할 수 있다.
3. **회고의 습관화**: '무엇을 했는지' 나열하는 것이 아니라, '어떤 문제를 겪었고 어떻게 해결했는지'를 기록하는 루틴을 만든다.

## 2. 학습 자료
- **메인 강의 (실습)**: [[패스트캠퍼스] 35개 프로젝트로 배우는 Android 앱 개발 feat. Jetpack Compose](https://github.com/Fastcampus-Android-Lecture-Project-2023)
    - 강의의 Part 0. Kotlin 기초/중급과 Part 1. 안드로이드 기본을 통해 문법과 안드로이드 OS의 기본 구조를 빠르게 훑고 실습
- **참고 도서 (이론)**: Kotlin in Action: 2/e (또는 자바에서 코틀린으로 등)
    - 강의에서 배운 문법이 실제 내부적으로 어떻게 구현되어 있는지 원리를 파악
- **보조 자료**: 공식 문서(Kotlin Docs), Decompile Tools(IntelliJ Kotlin Bytecode Viewer) 등

## 3. 주차별 계획

### 1주 차: 언어의 뿌리와 실행 환경 (JVM & Variable)
- **핵심 주제**: 코틀린은 어떻게 실행되는가? (JVM, 메모리, 변수)
- **학습 내용**: [강의] Part 0. Kotlin 기초 (오리엔테이션 ~ 변수, 조건식)
    - **컴파일 과정**: .kt 파일이 .class로 변환되는 과정과 JVM의 역할 (Python 인터프리터 방식과의 차이점).
    - **변수와 메모리**: val(읽기 전용)과 var의 차이가 메모리(Stack/Heap) 관점에서 어떻게 다른가? const val은 컴파일 시점에 어떻게 처리되는가?
    - **타입 시스템**: 코틀린의 타입 추론(Type Inference)은 컴파일 타임에 어떻게 확정되는가?

### 2주 차: 안전한 설계를 위한 타입 시스템 (Null Safety & Class)
- **핵심 주제**: 자바의 NullPointerException을 코틀린은 어떻게 방어하는가?
- **학습 내용**: [강의] Part 0. Kotlin 기초 (클래스, Null, 타입체크와 캐스팅)
    - **Null Safety**: Nullable과 Non-nullable 타입은 바이트코드 수준에서 어떻게 구분되는가? (Java와의 상호운용성 관점).
    - **클래스와 설계**: 코틀린의 class는 기본적으로 final이다. 상속을 닫아둔 설계 철학은 무엇이며, 이것이 유지보수에 미치는 영향은?
    - **데이터 클래스**: data class가 자동으로 생성해 주는 메서드(equals, hashCode 등)는 객체 비교에서 어떤 이점을 주는가?

### 3주 차: 함수형 프로그래밍과 모던 문법 (Lambda & Scope Functions)
- **핵심 주제**: 간결하고 표현력 있는 코드를 위한 함수형 패러다임.
- **학습 내용**: [강의] Part 0. Kotlin 중급 (람다, 확장함수, Scope function)
    - **람다와 고차 함수**: 람다식이 컴파일되면 익명 클래스로 변환되는 과정과 이에 따른 성능 비용(Performance Cost).
    - **inline 함수**: inline 키워드는 람다의 성능 오버헤드를 어떻게 줄여주는가?
    - **Scope Functions**: let, run, apply, also, with의 명확한 사용 기준은 무엇인가? (가독성 vs 간결성).

### 4주 차: 안드로이드 아키텍처와 뷰 시스템 (Android Basics & Compose)
- **핵심 주제**: 안드로이드 OS의 이해와 선언형 UI(Compose)의 등장 배경.
- **학습 내용**: [강의] Part 1. 안드로이드 기본 (Activity 생명주기, 뷰 그려지는 순서) 및 Part 4. Jetpack Compose 기초
    - **생명주기(Lifecycle)**: Activity가 생성되고 소멸할 때 메모리는 어떻게 관리되는가? (GC와의 관계).
    - **명령형 vs 선언형**: 기존 XML(명령형) 방식과 Jetpack Compose(선언형) 방식의 근본적인 사고방식 차이 (State 관리의 중요성).
    - **Context**: 안드로이드 개발에서 Context란 무엇이며, 왜 메모리 누수(Memory Leak)의 주원인이 되는가?

## 4. 회고 방식 (Retrospective)
우테코 레벨0 GitHub Repository를 생성, 주차별로 공부 기록을 남기고 주간 회고문(md) 파일 링크를 게시